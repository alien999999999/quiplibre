<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Quiplibre</title>
	<!--<script type="text/javascript" src="QuiplashQuestion.json"></script>-->
	<script type="text/javascript" src="ui_messages.json"></script>
	<link rel="stylesheet" href="css/game.css"></link>
	<script type="text/javascript" src="scripts/game.js"></script>
</head>
<body>
<div id="attrDiv"><i>Quiplibre is free software, under <a href="LICENSE.txt">AGPL v3+</a>. Its source code can be found <a href="https://github.com/wyattscarpenter/quiplibre">here</a>.</i></div>
<audio src="Quiplash/TalkshowExport/project/media/78614.mp3" loop="loop" autoplay="autoplay"></audio>
<div id="prevDiv"></div>
<div id="playDiv">
Hi, welcome to Quiplibre! Connect to wifi and visit happyfuntimes.net to join!<br>
No players established.
</div>
<div id="buttonDiv">
<button id="startButton" onClick="nextRound()"><script type="text/javascript">document.write(__(hostLanguages, "BtnStartGame"))</script></button>
</div>
<div id="gameCtrlDiv" style="display: none;">
	<button onclick="newGame()">New Game with Same Players</button><br>
	<button onclick="location.reload()">New Game with New Players</button><br>
	<a href="https://github.com/pucgenie/quiplibre">Submit prompts or improvements at GitHub</a>
</div>
</body>
<!-- <script src="prompts.json"></script>Databases are for suckers -->
<script type="text/javascript">
const happyfuntimes = require('happyfuntimes');

const server = new happyfuntimes.GameServer();

var prompts
lazyLoad('Quiplash/content/QuiplashQuestion.jet', json => prompts = json["content"])

// A new player has arrived.
server.on('playerconnect', netPlayer => {
	if (gameBegun){
		netPlayer.sendCmd('displayMessage', __(hostLanguages, "CantJoinRunningGame"))
		return
	}
	// pucgenie: possible race condition? No, JavaScript is single-threaded by default.
	players.push(new Player(netPlayer, "player" + (++playerId)))
})

// globals
var gameBegun = false
var playerId = 0
var players = []
var playerPairs = []
var pp = [] //the current playerPair
var round = 0
const maxRounds = 3 //a nice number of rounds
var votes = [[],[]]

class Player {
	constructor(netPlayer, name) {
		this.netPlayer = netPlayer
		this.name = name
		this.state = "nameless"
		this.prompts = []
		this.promptId = 0
		this.answers = []
		this.score = 0
		this.userLang = ["en"]

		const hue = randInt(360)
		const sat = randInt(2) * 50 + 50
		const val = 50
		this.color = "hsl(" + hue + "," + sat + "%," + val + "%)"

		netPlayer.addEventListener('disconnect', Player.prototype.disconnect.bind(this))
		netPlayer.addEventListener('receiveAnswer', Player.prototype.handleAnswer.bind(this))
		netPlayer.addEventListener('receiveChoice', Player.prototype.handleChoice.bind(this))
		netPlayer.addEventListener('userLang', Player.prototype.handleUserLang.bind(this));
	}

	disconnect() {
		const ndx = players.indexOf(this);
		if (ndx >= 0) {
			players.splice(ndx, 1);
		} else {
			console.log({"notfound": this})
		}
	}
	handleAnswer(cmd){
		//the idea is to check if the response is to the right question
		//to prevent errors
		//console.log(this);
		//console.log({"promptId":cmd.promptId, "answer":cmd.answer});
		if(cmd.answer==""){
			this.netPlayer.sendCmd('displayMessage', this.__("ignoringEmptyCmdAnswer"))
	return
		}
		switch (this.state) {
		case "rest":
			this.netPlayer.sendCmd("displayMessage", this.__("RestStateSoNoAction"))
		break
		case "nameless":
			if (cmd.promptId != 0) {
				this.netPlayer.sendCmd("displayMessage", this.__("NamelessUnexpectedPrompt", cmd))
	return
			}
			this.name = cmd.answer
			this.netPlayer.sendCmd("updateName", this.name);
			// pucgenie: why updateScore?
			this.netPlayer.sendCmd("updateScore", 0);
			this.state = "rest"
			this.netPlayer.sendCmd("displayMessage", this.__("GetReady"))
			replacePlayDiv(playDiv => {
				playDiv.appendChild(document.createTextNode(__(hostLanguages, "LastPlayerJoined")))
				var xB = document.createElement('b')
				xB.style.color = this.color
				xB.appendChild(document.createTextNode(cmd.answer))
				playDiv.appendChild(xB)
				playDiv.appendChild(document.createElement('br'))
				playDiv.appendChild(document.createTextNode(__(hostLanguages, "TotalPlayers", {totalPlayerCount: players.length})))
			})
		break
		case "prompt0":
			if (cmd.promptId != this.promptId){
				this.netPlayer.sendCmd("displayMessage", this.__("WrongQuestion1", {prompt: this.promptId, remotePrompt: cmd.promptId}))
			}
			this.answers.push(cmd.answer)
			this.state = "prompt1"
			this.promptId = this.prompts[1].promptId
			this.netPlayer.sendCmd("displayPrompt", this.prompts[1])
		break;
		case "prompt1":
			if (cmd.promptId != this.promptId){
				this.netPlayer.sendCmd("displayMessage", this.__("WrongQuestion2", {prompt: this.promptId, remotePrompt: cmd.promptId}))
			}
			this.answers.push(cmd.answer)
			this.state = "rest";
			this.netPlayer.sendCmd("displayMessage", this.__("PleaseWaitForOtherAnswers"))
			if(allPlayersHaveAnswered()){
				progressJudgement();
			}
		break;
		default:
			console.log({"playerName": this.name, "unexpectedState": this.state})
		break;
		}
	}
	handleChoice(cmd){
		console.log(cmd)
		console.log(this)
		if(cmd.promptId != this.promptId){//remember, == does not work on arrays
			console.log({"error": "ignoring choice as it's between incorrect options", "remotePromptId": cmd.promptId, "expectedPromptId": this.promptId})
			return
		}
		if(this.state != "choosing"){
			console.log("ignoring choice as player state is "+this.state);
			this.netPlayer.sendCmd("displayMessage", this.__("SuspectHacker"))
	return
		}
		votes[cmd.index].push(this)
		this.netPlayer.sendCmd("displayMessage", this.__("YouVotedFor", {voteNumber: cmd.index+1}))
		this.state = "rest"
		if(votes[0].length+votes[1].length == players.length){
			awardPoints()
			progressJudgement()
		}
	}
	__(key, basis, funcOut){
		return window.__(this.userLang, key, basis, funcOut)
	}
	handleUserLang(cmd){
		this.userLang = filterAvailableLanguages(cmd)
		this.netPlayer.sendCmd('displayPrompt', {id: 0, prompt: this.__("WhatsYourName")})
	}
}
Player.prototype.toString = function(){return this.name};

//game logic fns
function nextRound(){
	if (players.length <= 1){
		display("You need at least two people to connect "+
			"in order to play Quiplibre."
		)
return
	}
	gameBegun = true
	if (++round > maxRounds){
		endGame()
return
	}
	allPlayers(p => {p.prompts = []; p.answers = []})
	for (var xPlayer of players) { //todo: could refactor this to use allPlayers
		var xPrompt = pullPrompt()
		var xOpponent = pullRandomPlayer(xPlayer)
		var ppair = {player: xPlayer, opponent: xOpponent, prompt: xPrompt}
		playerPairs.push(ppair)
		xPlayer.prompts[0] = xPrompt
		xOpponent.prompts[1] = xPrompt
	}
	for (var xPlayer of players) {
		xPlayer.netPlayer.sendCmd("displayPrompt", xPlayer.prompts[0])
		xPlayer.state = "prompt0"
		xPlayer.promptId = xPlayer.prompts[0].id
	}

	display("Time for a nice round of Quiplibre! Round "+round+", to be exact!")
	buttonDiv.style.display = 'none'
}

function progressJudgement(){
	votes = [[],[]]
	if (playerPairs.length == 0){
		nextRound()
return
	}
	pp = playerPairs.splice(Math.floor(Math.random()*playerPairs.length), 1)[0]
	display("<p><b>"+pp.prompt.prompt+"</b></p>"+
		"<p>"+pp.player.answers[0]+
		"<br>OR<br>"+
		pp.opponent.answers[1]+"</p>"
	)
	var pfad1 = 'Quiplash/content/QuiplashQuestion/' + pp.prompt.id
	lazyLoad(pfad1 + '/data.jet', json => {
		new Audio(pfad1 + "/" + json['fields'].filter(feld => feld['n'] == "PromptAudio")[0]['v'] + ".mp3").play()
	})
	var choices = {
		"possibilities": [pp.player.answers[0], pp.opponent.answers[1]],
		"promptId": pp.prompt.id
	}
	allPlayers(p => {
		p.netPlayer.sendCmd("displayChoice", choices)
		p.state = "choosing"
		p.promptId = choices.promptId
	})
}

/**
 * Clears playDiv and calls func(playDiv), which should add elements to playDiv ("display something").
**/
function replacePlayDiv(func){
	// pucgenie: simply use style.display instead of style.visibility="hidden"|"visible" .
	playDiv.style.display = 'none'
	clearElementChilds(playDiv)
	func(playDiv)
	playDiv.style.display = 'block'
}

function awardPoints(){
	attrDiv.style.display = 'none'
	prevDiv.style.display = 'none'
	clearElementChilds(prevDiv)
	prevDiv.appendChild(document.createTextNode("Previous result:"))
	prevDiv.appendChild(document.createElement("br"))
	for(var i = 0; i < votes.length; ++i){
		var xPlayer = i == 0 ? pp.player : pp.opponent
		var xVotes = votes[i]
		xPlayer.score += xVotes.length * round
		xPlayer.netPlayer.sendCmd("updateScore", xPlayer.score)
		__(hostLanguages, "wonVotesPoints", {"Player": xPlayer, "Votes": xVotes}, xNeu => prevDiv.appendChild(document.createTextNode(xNeu)))
	}
	prevDiv.appendChild(document.createElement('br'))
	prevDiv.style.display = 'block'
}

function endGame(){
	sortPlayers()
	replacePlayDiv(playDiv => {
		var erstAbsatz = document.createElement('p')
		erstAbsatz.appendChild(document.createTextNode("End of the game! Here's a scoreboard:"))
		playDiv.appendChild(erstAbsatz)
		var xTbody = document.createElement('tbody')
		players.forEach(p => {
			var xTr = document.createElement('tr')
			[p.name, p.score].forEach(xTxt => {
				var xTd = document.createElement('td')
				xTd.appendChild(document.createTextNode(xTxt))
				xTr.appendChild(xTd)
			})
			xTbody.appendChild(xTr)
		})
		var xTable = document.createElement('table')
		xTable.classList.add('')
		xTable.appendChild(xTbody)
		playDiv.appendChild(xTable)
	})
	gameCtrlDiv.style.display = 'block'
	attrDiv.style.display = 'block'
	//todo: could send something to players
	players.forEach(xPlayer => xPlayer.netPlayer.sendCmd('displayMessage', xPlayer.__("GameEnded")))
}

function newGame(){
	gameCtrlDiv.style.display = 'none'
	clearElementChilds(prevDiv)
	prevDiv.appendChild(document.createTextNode("Previous winner: "+players[0]))
	round = 0
	allPlayers(p => {
		p.score = 0
		p.netPlayer.sendCmd('updateScore', 0)
	})
	// pucgenie: disabled exceptional line of code.
	//nextRound()
	buttonDiv.style.display = 'block'
}

//helper & utility fns
function display(html){playDiv.innerHTML = html}

function pullPrompt(){
	if (prompts.length == 0){
		return {prompt: "What's a good prompt for a round of Quiplibre?"+
			" (Please send us the winning answer of this round, "+
			"as you have exhausted our list of prompts)", id: 0}
	}
	return prompts.splice(Math.floor(Math.random()*prompts.length), 1)[0]
}

var randomPlayers = []
function pullRandomPlayer(excludedPlayer){
	//remember that excludedPlayer is just a reference to a player
	//use slice to copy array values, not a reference:
	if (randomPlayers.length == 0){
		randomPlayers = players.slice()
	}
	tmpPlayers = randomPlayers.filter(p => (p != excludedPlayer))
	var i = Math.floor(Math.random()*(randomPlayers.length-1))
	randomPlayers = randomPlayers.filter(p => (p != tmpPlayers[i]))
	return tmpPlayers[i]
}

function allPlayers(pred){ //query all players or apply a fn to them
	ret = true
	for (var xPlayer of players) {
		ret = (pred(xPlayer)) && ret //must avoid short-circuit eval
	}
	return ret
}

function allPlayersHaveAnswered(){
	return allPlayers(p => p.answers.length==2)
}

function sortPlayers(){//descending. In-place and returns arr
	return players.sort((a, b) => (b.score - a.score))
}
</script>
</html>
