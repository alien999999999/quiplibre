<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Quiplibre</title>
	<script type="text/javascript" src="QuiplashQuestion.json"></script>
	<script type="text/javascript" src="ui_messages.json"></script>
</head>
<body>
<div id="attrDiv"><i>Quiplibre is free software, under <a href="LICENSE.txt">AGPL v3+</a>. Its source code can be found <a href="https://github.com/wyattscarpenter/quiplibre">here</a>.</i></div>
<div id="prevDiv"></div>
<div id="playDiv">
Hi, welcome to Quiplibre! Connect to wifi and visit happyfuntimes.net to join!<br>
No players established.
</div>
<div id="buttonDiv">
<button id="startButton" onClick="nextRound()">start the game</button>
</div>
<div id="gameCtrlDiv" style="display: none;">
	<button onclick="newGame()" value>New Game with Same Players</button><br>
	<button onclick="location.reload()" value>New Game with New Players</button><br>
	<a href="https://github.com/pucgenie/quiplibre">Submit prompts or improvements at GitHub</a>
</div>
</body>
<!-- <script src="prompts.json"></script>Databases are for suckers -->
<script type="text/javascript">
const happyfuntimes = require('happyfuntimes');
if (!navigator.languages) {
	navigator.languages = [navigator.language || navigator.userLanguage]
	navigator.languages.push(navigator.languages[0].substring(0, 2))
}
const userLang = []
for (var setULang of navigator.languages) {
	if (ui_messages.hasOwnProperty(setULang)) {
		userLang.push(setULang)
break
	}
}
for (var setULang of navigator.languages) {
	setULang = setULang.substring(0, 2)
	if (ui_messages.hasOwnProperty(setULang)) {
		userLang.push(setULang)
break
	}
}
// pucgenie: the default language has to contain all keys
userLang.push("en")

const firstUserLang = userLang.slice(0, 1)[0]
const uebersetz = ui_messages[firstUserLang]
/**
 * Full-blown translate-and-format function.
 * Quite some overhead...
 * @author pucgenie@hotmail.com
**/
function __(key, basis) {
	var ret = uebersetz[key]
	if (!ret) {
		for (var altLang of userLang) {
			ret = ui_messages[altLang][key]
			if (ret) {
		break
			}
		}
	}
	return appendFormattedText(ret, basis).join('')
}

const server = new happyfuntimes.GameServer();

const prompts = prompts2["content"]
prompts2 = undefined

// A new player has arrived.
server.on('playerconnect', netPlayer => {
	if (gameBegun){
		netPlayer.sendCmd('displayMessage', __("CantJoinRunningGame"))
		return
	}
	// pucgenie: possible race condition? No, JavaScript is single-threaded by default.
	console.log(
		players.push(new Player(netPlayer, "player" + (++playerId)))
	)
});

// globals
var gameBegun = false;
var playerId = 0;
var players = [];
var playerPairs = [];
var pp = []; //the current playerPair
var round = 0;
const maxRounds = 3; //a nice number of rounds
var votes = [[],[]]

function randInt(min, max) {
	if (max === undefined) {
		max = min;
		min = 0;
	}
	return Math.random() * (max - min) + min | 0;
}

class Player {
	constructor(netPlayer, name) {
		this.netPlayer = netPlayer;
		this.name = name;
		this.state = "nameless";
		this.prompts = [];
		this.promptId = 0
		this.answers = [];
		this.score = 0;

		const hue = randInt(360);
		const sat = randInt(2) * 50 + 50;
		const val = 50;
		this.color = "hsl(" + hue	+ "," + sat + "%," + val + "%)";

		netPlayer.addEventListener('disconnect', Player.prototype.disconnect.bind(this));
		netPlayer.addEventListener('receiveAnswer', Player.prototype.handleAnswer.bind(this));
		netPlayer.addEventListener('receiveChoice', Player.prototype.handleChoice.bind(this));
		netPlayer.sendCmd('displayPrompt', {promptId: 0, prompt: "What is your name?"});
	}

	disconnect() {
		const ndx = players.indexOf(this);
		if (ndx >= 0) {
			players.splice(ndx, 1);
		} else {
			console.log({"notfound": this})
		}
	}
	handleAnswer(cmd){
		//the idea is to check if the response is to the right question
		//to prevent errors
		console.log(this);
		console.log({"promptId":cmd.promptId, "answer":cmd.answer});
		if(cmd.answer==""){
			this.netPlayer.sendCmd('displayMessage', __("ignoringEmptyCmdAnswer"))
	return
		}
		switch (this.state) {
		case "rest":
			this.netPlayer.sendCmd("displayMessage", __("RestStateSoNoAction"))
		break
		case "nameless":
			if (cmd.promptId != 0) {
				this.netPlayer.sendCmd("displayMessage", __("NamelessUnexpectedPrompt", cmd))
	return
			}
			this.name = cmd.answer
			this.netPlayer.sendCmd("updateName", this.name);
			// pucgenie: why updateScore?
			this.netPlayer.sendCmd("updateScore", 0);
			this.state = "rest"
			this.netPlayer.sendCmd("displayMessage",
				__("GetReady"));
			display("<p>Last player to join: <b style=\"color: " + this.color + "\">"+cmd.answer+
				"</b><br>total players: "+playerId+"</p>"
			)
		break
		case "prompt0":
			if (cmd.promptId !== this.promptId){
				this.netPlayer.sendCmd("displayMessage", __("WrongQuestion1", {prompt: this.promptId, remotePrompt: cmd.promptId}))
			}
			this.answers[0] = cmd.answer
			this.state = "prompt1"
			this.promptId = this.prompts[1].promptId
			this.netPlayer.sendCmd("displayPrompt", this.prompts[1])
		break;
		case "prompt1":
			if (cmd.promptId !== this.promptId){
				this.netPlayer.sendCmd("displayMessage", __("WrongQuestion2", {prompt: this.promptId, remotePrompt: cmd.promptId}))
			}
			this.answers[1] = cmd.answer
			this.state = "rest";
			this.netPlayer.sendCmd("displayMessage", __("PleaseWaitForOtherAnswers"))
			if(allPlayersHaveAnswered()){
				progressJudgement();
			}
		break;
		default:
			console.log({"playerName": this.name, "unexpectedState": this.state})
		break;
		}
	}
	handleChoice(cmd){
		console.log(cmd)
		console.log(this)
		if(cmd.promptId != this.promptId){//remember, == does not work on arrays
			console.log({"error": "ignoring choice as it's between incorrect options", "remotePromptId": cmd.promptId, "expectedPromptId": this.promptId})
			return
		}
		if(this.state != "choosing"){
			console.log("ignoring choice as player state is "+this.state);
			this.netPlayer.sendCmd("displayMessage", "We suspect you as hacker.")
	return
		}
		votes[cmd.index].push(this)
		this.netPlayer.sendCmd("displayMessage","<p>You voted for option "+(cmd.index+1)+".</p>")
		this.state = "rest"
		if(votes[0].length+votes[1].length == players.length){
			awardPoints()
			progressJudgement()
		}
	}
}
Player.prototype.toString = function(){return this.name};

//game logic fns
function nextRound(){
	if (players.length <= 1){
		display("You need at least two people to connect "+
			"in order to play Quiplibre."
		)
return
	}
	gameBegun = true
	if (++round > maxRounds){
		endGame()
return
	}
	allPlayers(p => {p.prompts = [null,null]; p.answers = [null,null]})
	for (var xPlayer of players) { //todo: could refactor this to use allPlayers
		var xPrompt = pullPrompt()
		var xOpponent = pullRandomPlayer(xPlayer)
		var ppair = {player: xPlayer, opponent: xOpponent, prompt: xPrompt}
		playerPairs.push(ppair)
		xPlayer.prompts[0] = xPrompt
		xOpponent.prompts[1] = xPrompt
	}
	for (var xPlayer of players) {
		xPlayer.netPlayer.sendCmd("displayPrompt", xPlayer.prompts[0])
		xPlayer.state = "prompt0"
		xPlayer.promptId = xPlayer.prompts[0].promptId
	}

	display("<p>Time for a nice round of Quiplibre! Round "+round+", to be exact!</p>")
	buttonDiv.style.display = 'none'
}

function progressJudgement(){
	votes = [[],[]]
	if (playerPairs.length == 0){
		nextRound()
return
	}
	pp = playerPairs.splice(Math.floor(Math.random()*playerPairs.length), 1)[0]
	display("<p><b>"+pp[2].prompt+"</b></p>"+
		"<p>"+pp[0].answers[0]+
		"<br>OR<br>"+
		pp[1].answers[1]+"</p>"
	)
	var choices = {
		"possibilities": [pp[0].answers[0], pp[1].answers[1]],
		"promptId": pp[2].promptId
	}
	allPlayers(p => {
		p.netPlayer.sendCmd("displayChoice", choices)
		p.state = "choosing"
		p.promptId = choices.promptId
	})
}

function appendFormattedText(txtTmpl, basis, funcOut){
	var ret
	if (!funcOut) {
		ret = []
		funcOut = xWert => ret.push(xWert)
	}
	for(var txtTeil of txtTmpl){
		if(txtTeil.startsWith("${")){
			// may not contain "(),;"
			//if(!txtTeil.endsWith("}")) throw "defective/malicious template detected"
			funcOut(eval("basis." + txtTeil.substring(2, txtTeil.length - 1)))
	continue
		}
		funcOut(txtTeil)
	}
	return ret
}

function clearElementChilds(xElem){
	while(xElem.firstChild){
		xElem.removeChild(xElem.firstChild)
	}
}

/**
 * Clears playDiv and calls func(playDiv), which should add elements to playDiv ("display something").
**/
function replacePlayDiv(func){
	// pucgenie: simply use style.display instead of style.visibility="hidden"|"visible" .
	playDiv.style.display = 'none'
	clearElementChilds(playDiv)
	func(playDiv)
	playDiv.style.display = 'block'
}

function awardPoints(){
	attrDiv.style.display = 'none'
	prevDiv.style.display = 'none'
	clearElementChilds(prevDiv)
	prevDiv.appendChild(document.createTextNode("Previous result:"))
	prevDiv.appendChild(document.createElement("br"))
	var wonVotesPoints = ["${Player.name}", " won ", "${Votes.length}", " votes and thus ", "${Player.score}", " points!"]
	for(var i = 0; i < votes.length; ++i){
		var xPlayer = pp[i]
		var xVotes = votes[i]
		xPlayer.score += xVotes.length * round
		xPlayer.netPlayer.sendCmd("updateScore", xPlayer.score)
		appendFormattedText(wonVotesPoints, xNeu => prevDiv.appendChild(document.createTextNode(xNeu)), {"Player": xPlayer, "Votes": xVotes})
	}
	prevDiv.appendChild(document.createElement('br'))
	prevDiv.style.display = 'block'
}

function endGame(){
	sortPlayers()
	replacePlayDiv(playDiv => {
		var erstAbsatz = document.createElement('p')
		erstAbsatz.appendChild(document.createTextNode("End of the game! Here's a scoreboard:"))
		playDiv.appendChild(erstAbsatz)
		var xTbody = document.createElement('tbody')
		players.forEach(p => {
			var xTr = document.createElement('tr')
			[p.name, p.score].forEach(xTxt => {
				var xTd = document.createElement('td')
				xTd.appendChild(document.createTextNode(xTxt))
				xTr.appendChild(xTd)
			})
			xTbody.appendChild(xTr)
		})
		var xTable = document.createElement('table')
		xTable.classList.add('')
		xTable.appendChild(xTbody)
		playDiv.appendChild(xTable)
	})
	gameCtrlDiv.style.display = 'block'
	attrDiv.style.display = 'block'
	//todo: could send something to players
	players.forEach(xPlayer => xPlayer.netPlayer.sendCmd('displayMessage', __("GameEnded")))
}

function newGame(){
	gameCtrlDiv.style.display = 'none'
	clearElementChilds(prevDiv)
	prevDiv.appendChild(document.createTextNode("Previous winner: "+players[0]))
	round = 0
	allPlayers(p => {
		p.score = 0
		p.netPlayer.sendCmd('updateScore', 0)
	})
	// pucgenie: disabled exceptional line of code.
	//nextRound()
	buttonDiv.style.display = 'block'
}

//helper & utility fns
function display(html){playDiv.innerHTML = html}

function pullPrompt(){
	if (prompts.length == 0){
		return {prompt: "What's a good prompt for a round of Quiplibre?"+
			" (Please send us the winning answer of this round, "+
			"as you have exhausted our list of prompts)", promptId: 0}
	}
	return prompts.splice(Math.floor(Math.random()*prompts.length), 1)[0]
}

var randomPlayers = []
function pullRandomPlayer(excludedPlayer){
	//remember that excludedPlayer is just a reference to a player
	//use slice to copy array values, not a reference:
	if (randomPlayers.length == 0){
		randomPlayers = players.slice()
	}
	var i = Math.floor(Math.random()*(randomPlayers.length-2))
	tmpPlayers = randomPlayers.filter(p => (p != excludedPlayer))
	randomPlayers = randomPlayers.filter(p => (p != tmpPlayers[i]))
	return tmpPlayers[i]
}

function allPlayers(pred){ //query all players or apply a fn to them
	ret = true
	for (var xPlayer of players) {
		ret = (pred(xPlayer)) && ret //must avoid short-circuit eval
	}
	return ret
}

function allPlayersHaveAnswered(){
	return allPlayers(p => p.answers.length==2)
}

function sortPlayers(){//descending. In-place and returns arr
	return players.sort((a, b) => (b.score - a.score))
}
</script>
</html>
